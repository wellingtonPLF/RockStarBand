"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const msgpack_1 = require("@msgpack/msgpack");
const core_1 = require("@logtail/core");
const context_1 = require("./context");
class Node extends core_1.Base {
    constructor(sourceToken, options) {
        super(sourceToken, options);
        // Sync function
        const sync = async (logs) => {
            const res = await (0, cross_fetch_1.default)(this._options.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/msgpack",
                    Authorization: `Bearer ${this._sourceToken}`,
                    "User-Agent": "logtail-js(node)",
                },
                body: this.encodeAsMsgpack(logs),
            });
            if (res.ok) {
                return logs;
            }
            throw new Error(res.statusText);
        };
        // Set the throttled sync function
        this.setSync(sync);
    }
    /**
     * Override `Base` log to enable Node.js streaming
     *
     * @param message: string - Log message
     * @param level (LogLevel) - Level to log at (debug|info|warn|error)
     * @param context: (Context) - Log context for passing structured data
     * @param stackContextHint: (StackContextHint|null) - Info about which methods to consider as origin in context.runtime
     * @returns Promise<ILogtailLog> after syncing
     */
    async log(message, level, context = {}, stackContextHint) {
        // Process/sync the log, per `Base` logic
        context = Object.assign(Object.assign({}, (0, context_1.getStackContext)(this, stackContextHint)), context);
        const processedLog = await super.log(message, level, context);
        // Push the processed log to the stream, for piping
        if (this._writeStream) {
            this._writeStream.write(JSON.stringify(processedLog) + "\n");
        }
        // Return the transformed log
        return processedLog;
    }
    /**
     * Pipe JSON stringified `ILogtailLog` to a stream after syncing
     *
     * @param stream - Writable|Duplex stream
     */
    pipe(stream) {
        this._writeStream = stream;
        return stream;
    }
    encodeAsMsgpack(logs) {
        const encoded = (0, msgpack_1.encode)(logs);
        const buffer = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
        return buffer;
    }
}
exports.Node = Node;
//# sourceMappingURL=node.js.map